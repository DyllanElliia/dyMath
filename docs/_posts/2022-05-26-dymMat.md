---
title: DyMath Matrix 矩阵
author: DyllanElliia
date: 2022-05-26
category: Jekyll
layout: post
---

dyMath提供的矩阵的结构和部分数学库的矩阵有点不同，因此在开始介绍前需要来一点定义：

假如有个矩阵，它等效于如下数学矩阵：

$$
\mathbf A=\begin{pmatrix}
1&2&3\\4&5&6\\7&8&9
\end{pmatrix}
$$

定义`Matrix`索引和矩阵下标的关系如下所示：

$$
\mathbf {A[i][j]}=\mathbf A_{i+1,j+1}
$$

使用`Matrix`索引进行赋值：

~~~cpp
A[1][0] = 0, A[1][2]=0;
~~~

该操作等效于：

$$
\mathbf A=\begin{pmatrix}
1&2&3\\4&5&6\\7&8&9
\end{pmatrix}
\Rightarrow
\mathbf A=\begin{pmatrix}
1&2&3\\\color{red}0&5&\color{red}0\\7&8&9
\end{pmatrix}
$$

## 基本操作

### 创建一个矩阵

~~~cpp
template <typename Type, std::size_t m, std::size_t n>
struct Matrix;
~~~

创建一个矩阵需要声明它的变量类型和存储大小，其中，大小的`m`和`n`和数学矩阵的对应关系如下：

$$
\mathbf A_{m,n}=\begin{pmatrix}
        a_{11}    &  \dots  &a_{1n}  \\

        \vdots& \ddots  &  \vdots \\

        a_{m1}  & \dots  &   a_{mn}
\end{pmatrix}
$$

可以使用如下方法创建一个矩阵：

~~~cpp
dym::Matrix<Real, 2, 4> a(1);
Out: a = [[1.0, 1.0, 1.0, 1.0]
          [1.0, 1.0, 1.0, 1.0]]
~~~

若你想创造一个单位矩阵，可以使用如下数学方法：

~~~cpp
auto a = dym::matrix::identity<Real, 3>();
auto b = dym::matrix::identity<Real, 3>(2.0);
Out: a = [[1.0, 0.0, 0.0]
          [0.0, 1.0, 0.0]
          [0.0, 0.0, 1.0]]
     b = [[2.0, 0.0, 0.0]
          [0.0, 2.0, 0.0]
          [0.0, 0.0, 2.0]]
~~~

同样，也可以使用数字作为初始化参数：

~~~cpp
dym::Matrix<Real, 2, 4> a({{1.0, 2.0, 3.0, 4.0},
                           {5.0, 6.0, 7.0, 8.0}});
Out: a = [[1.0, 2.0, 3.0, 4.0]
          [5.0, 6.0, 7.0, 8.0]]
~~~

向量也可以作为初始化参数，但是是水平排列的：

~~~cpp
dym::Matrix<Real, 2, 4> a({dym::Vector<Real, 4>(1.0),
                           dym::Vector<Real, 4>(2.0),});
Out: a = [[1.0, 1.0, 1.0, 1.0]
          [2.0, 2.0, 2.0, 2.0]]
~~~

矩阵初始化同样支持Lambda表达式，下面创建方法的结果均一样：

~~~cpp
// method 1:
int i = 0;
dym::Matrix<Real, 2, 4> a([&](Real &e){ e = (++i);});

// method 2:
dym::Matrix<Real, 2, 4> a([&](Real &e, int i, int j){ 
  e = i * 4 + j + 1;
});

// method 3:
dym::Vector<Real, 4> v([&](Real &e, int i){ e = i + 1;});
dym::Matrix<Real, 2, 4> a([&](dym::Vector<Real, 4> &e){ 
  e = v;
  v += 4.0;
});

// method 4:
dym::Vector<Real, 4> v([&](Real &e, int i){ e = i + 1;});
dym::Matrix<Real, 2, 4> a([&](dym::Vector<Real, 4> &e, 
                              int i){ 
  e = dym::Vector<Real, 4>([&](Real &ve, int vi){
    ve = i * 4 + vi + 1; });
});

Out: a = [[1.0, 2.0, 3.0, 4.0]
          [5.0, 6.0, 7.0, 8.0]]
~~~
