---
title: DyMath Matrix 矩阵
author: DyllanElliia
date: 2022-05-26
category: Jekyll
layout: post
---

dyMath提供的矩阵的结构和部分数学库的矩阵有点不同，因此在开始介绍前需要来一点定义：

假如有个矩阵，它等效于如下数学矩阵：

$$
\mathbf A=\begin{pmatrix}
1&2&3\\4&5&6\\7&8&9
\end{pmatrix}
$$

定义`Matrix`索引和矩阵下标的关系如下所示：

$$
\mathbf {A[i][j]}=\mathbf A_{i+1,j+1}
$$

使用`Matrix`索引进行赋值：

~~~cpp
A[1][0] = 0, A[1][2]=0;
~~~

该操作等效于：

$$
\mathbf A=\begin{pmatrix}
1&2&3\\4&5&6\\7&8&9
\end{pmatrix}
\Rightarrow
\mathbf A=\begin{pmatrix}
1&2&3\\\color{red}0&5&\color{red}0\\7&8&9
\end{pmatrix}
$$

## 基本操作

### 创建一个矩阵

~~~cpp
template <typename Type, std::size_t m, std::size_t n>
struct Matrix;
~~~

创建一个矩阵需要声明它的变量类型和存储大小，其中，大小的`m`和`n`和数学矩阵的对应关系如下：

$$
\mathbf A_{m,n}=\begin{pmatrix}
        a_{11}    &  \dots  &a_{1n}  \\

        \vdots & \ddots  &  \vdots \\

        a_{m1}  & \dots  &   a_{mn}
\end{pmatrix}
$$

可以使用如下方法创建一个矩阵：

~~~cpp
dym::Matrix<Real, 2, 4> a(1);
Out: a = [[1.0, 1.0, 1.0, 1.0]
          [1.0, 1.0, 1.0, 1.0]]
~~~

若你想创造一个单位矩阵，可以使用如下数学方法：

~~~cpp
auto a = dym::matrix::identity<Real, 3>();
auto b = dym::matrix::identity<Real, 3>(2.0);
Out: a = [[1.0, 0.0, 0.0]
          [0.0, 1.0, 0.0]
          [0.0, 0.0, 1.0]]
     b = [[2.0, 0.0, 0.0]
          [0.0, 2.0, 0.0]
          [0.0, 0.0, 2.0]]
~~~

同样，也可以使用数字作为初始化参数：

~~~cpp

Out: a = [[1.0, 2.0, 3.0, 4.0]
          [5.0, 6.0, 7.0, 8.0]]
~~~

向量也可以作为初始化参数，但是是水平排列的：

~~~cpp
dym::Matrix<Real, 2, 4> a({dym::Vector<Real, 4>(1.0),
                           dym::Vector<Real, 4>(2.0)});
Out: a = [[1.0, 1.0, 1.0, 1.0]
          [2.0, 2.0, 2.0, 2.0]]
~~~

矩阵初始化同样支持Lambda表达式，下面创建方法的结果均一样：

~~~cpp
// method 1:
int i = 0;
dym::Matrix<Real, 2, 4> a([&](Real &e){ e = (++i);});

// method 2:
dym::Matrix<Real, 2, 4> a([&](Real &e, int i, int j){ 
  e = i * 4 + j + 1;
});

// method 3:
dym::Vector<Real, 4> v([&](Real &e, int i){ e = i + 1;});
dym::Matrix<Real, 2, 4> a([&](dym::Vector<Real, 4> &e){ 
  e = v;
  v += 4.0;
});

// method 4:
dym::Vector<Real, 4> v([&](Real &e, int i){ e = i + 1;});
dym::Matrix<Real, 2, 4> a([&](dym::Vector<Real, 4> &e, 
                              int i){ 
  e = dym::Vector<Real, 4>([&](Real &ve, int vi){
    ve = i * 4 + vi + 1; });
});

Out: a = [[1.0, 2.0, 3.0, 4.0]
          [5.0, 6.0, 7.0, 8.0]]
~~~

> 上述重点展示有4中基于Lambda的创建矩阵的方法。

### 矩阵操作符

dyMath提供的`Matrix`的`=`和`cast`与`Vector`的机制一样，此处不再赘述。

除外，还有常用数学操作符，首先为了简写，使用`R`代表实数`Real`和`Reali`等，使用`V`代表向量`Vector`，使用`M`代表矩阵`Matrix`：

| 操作符 | 操作                | 备注                         |
| :----: | :------------------ | :--------------------------- |
|  `+`   | `R+M`, `M+R`, `M+M` |                              |
|  `-`   | `R-M`, `M-R`, `M-M` |                              |
|  `*`   | `R*M`, `M*R`, `M*V`, `M*M` | `M*V`为矩阵和向量的乘积，`M*M`为矩阵叉乘                           |
|  `/`   | `R/M`, `M/R`        |                              |
|  `+=`  | `M+=R`, `M+=M`      |                              |
|  `-=`  | `M-=R`, `M-=M`      |                              |
|  `*=`  | `M*=R`      |                              |
|  `/=`  | `M/=R`      |                              |

### 元素访问

最基础的元素访问，就是上文提到的：

~~~cpp
a[i][j] = 0;
~~~

除外，有很多图形学开发者希望使用基于列向量的访问，因此提供了下面两个接口：

~~~cpp
auto a = dym::matrix::identity<Real, 3>();

// 获取第0列的列向量
auto v0 = a.getColVec(0);

// 列向量写入第2列
a.setColVec(2, v0 * 1.5);

Out: a = [[1.0, 0.0, 1.5]
          [0.0, 1.0, 0.0]
          [0.0, 0.0, 0.0]]
~~~

### 输出 & 命令行显示

同`Vector`，`Matrix`提供了`<<`和`show`两种命令行输出方法，且调用效果一致。

## 矩阵数值方法

### sub 余子式

dyMath使用`Matrix`实现行列式，`sub`可以获取矩阵$\mathbf A$的余子式$\mathbf A_{ij}$：

~~~cpp
auto a = dym::matrix::identity<Real, 3>();
auto aij = a.sub(0, 1);
Out: aij = [[0.0, 0.0]
            [0.0, 1.0]]
~~~

### det 行列式值

使用`det`可以计算一个矩阵的行列式值：

~~~cpp
auto a = dym::matrix::identity<Real, 3>();
auto b = a.det();
Out: b = 1.0
~~~

### inverse 逆矩阵

dyMath提供了一个效率较高的逆矩阵计算方案：

~~~cpp
auto b = a * a.inverse();
// inv 为简写inverse，完全等效
auto b = a * a.inv();
~~~

### trace 迹

可以使用`trace`和`tr`计算一个矩阵的迹：

~~~cpp
auto b = a.trace();
auto b = a.tr();
~~~

### transpose 转置

使用`transpose`获得矩阵的转置矩阵：

~~~cpp
auto at = a.transpose();
auto at = dym::matrix::transposed(a);
~~~

### outer_product 向量外积

向量外积放在这里，是因为它的结果是一个矩阵，因此我将它归类在了矩阵方法。

~~~cpp
auto b = dym::matrix::outer_product(
  dym::Vector<Real, 2>({1.0,2.0}),
  dym::Vector<Real, 2>({3.0,4.0}));
Out: b = [[3.0, 4.0], 
          [6.0, 8.0]]
~~~

### SVD 奇异值分解

dyMath支持SVD分解，且提供一个针对32浮点的快速分解方案，支持截断奇异值分解：

~~~cpp
dym::Matrix<Real, 3, 3> A(...) U, Sig, V;
dym::matrix::svd(a, U, Sig, V);

// 快速3x3 32位浮点奇异值分解
dym::Matrix<float, 3, 3> A(...) U, Sig, V;
dym::matrix::svd(a, U, Sig, V, true);
~~~

> 若不是32位浮点，设置了`use_fast3x3Svd`为`true`也不会有效果。

|SVD方案|耗时（运行$10^5$次）|平均误差|
|:---:|:---:|:---:|
|截断奇异值分解|0.078159s|2.95544e-17|
|传统3x3奇异值分解|0.055009s |1.71387e-12|
|快速3x3奇异值分解|0.014366s|0.00078451|

快速3x3很快，但精度不高，因此要酌情使用。这里对截断奇异值分解的测试是3x3矩阵，但它可以分解任意大小矩阵，且精度很高。

### PD 极分解

PD分解是`svd`的一种拓展算法：

~~~cpp
dym::Matrix<Real, 3, 3> A(...) U, P;
dym::matrix::pd(a, U, P);
~~~

### for_each 遍历

dyMath提供了`for_each`方法，用户遍历`Matrix`元素时，可以使用该方法实现基于循环展开的遍历操作：

~~~cpp
a.for_each([&](Real &e){ e = 0.0;});

a.for_each([&](Real &e, int i, int j){
  if (i == j) e = 1.0;
  else e = 0.0;
});
~~~

### shape 维度

`shape`返回一个标记`Index`，这是一个历史残留变量，未来指不定哪天会被优化掉，你可以理解为一个`dym::Vector<int, ?>()`，但它的大小是可变的、未知的，这到介绍`Tensor`时，你就可以知道为什么这样设定。

~~~cpp
dym::Matrix<Real, 3, 4> a;

auto b = a.shape();
Out: b = [3, 4]
~~~
